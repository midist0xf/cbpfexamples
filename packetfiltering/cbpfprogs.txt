================== INTRODUCTION ============================

For each filter are shown three representations:
1) human readable instructions generated by tcpdump -d
2) instructions as C code fragment generated by tcdump -dd
3) human readable instructions written using linux/filter.h 
macros

2 and 3 can be used to initialize a struct sock_filter 

================ HOW TO USE A FILTER =======================

Copy filter instructions (in the format 2 or 3) and paste  
them in the initialization block of struct sock_prog bpfcode[]
within raw.c.
Uncomment/comment the functions to print the correct headers.

================== IP4 =====================================

tcpdump ip -d
  
(000) ldh      [12]                      
(001) jeq      #0x800    jt 2  jf 3     
(002) ret      #262144                  
(003) ret      #0                   

tcpdump ip -dd

{ 0x28, 0, 0, 0x0000000c }, 
{ 0x15, 0, 1, 0x00000800 }, 
{ 0x6, 0, 0, 0x00040000 },  
{ 0x6, 0, 0, 0x00000000 },  

linux/filter.h macros

BPF_STMT(BPF_LD+BPF_H+BPF_ABS, 12), 
BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, 0x800, 0, 1),
BPF_STMT(BPF_RET+BPF_K, 0x40000),
BPF_STMT(BPF_RET+BPF_K, 0),

================== IP4 E TCP ===============================

tcpdump ip and tcp -d

(000) ldh      [12]
(001) jeq      #0x800           jt 2   jf 5
(002) ldb      [23]
(003) jeq      #0x6             jt 4   jf 5
(004) ret      #262144
(005) ret      #0

tcpdump ip and tcp -dd

{ 0x28, 0, 0, 0x0000000c },
{ 0x15, 0, 3, 0x00000800 },
{ 0x30, 0, 0, 0x00000017 },
{ 0x15, 0, 1, 0x00000006 },
{ 0x6, 0, 0, 0x00040000 },
{ 0x6, 0, 0, 0x00000000 },

linux/filter.h macros

/* check if ethernet type field is ip4 */
BPF_STMT(BPF_LD+BPF_H+BPF_ABS, 12),
BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, 0x800, 0, 3),
/* check if ip protocol field is tcp */
BPF_STMT(BPF_LD+BPF_B+BPF_ABS, 23),
BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, 0x6,  0, 1),
/* return the entire packet */
BPF_STMT(BPF_RET+BPF_K, 0x40000),
/* discard the packet */
BPF_STMT(BPF_RET+BPF_K, 0),

================= TCP =====================================

tcpdump tcp -d

(000) ldh      [12]
(001) jeq      #0x86dd          jt 2   jf 7
(002) ldb      [20]
(003) jeq      #0x6             jt 10  jf 4
(004) jeq      #0x2c            jt 5   jf 11
(005) ldb      [54]
(006) jeq      #0x6             jt 10  jf 11
(007) jeq      #0x800           jt 8   jf 11
(008) ldb      [23]
(009) jeq      #0x6             jt 10  jf 11
(010) ret      #262144
(011) ret      #0

tcpdump tcp -dd

{ 0x28, 0, 0, 0x0000000c },
{ 0x15, 0, 5, 0x000086dd },
{ 0x30, 0, 0, 0x00000014 },
{ 0x15, 6, 0, 0x00000006 },
{ 0x15, 0, 6, 0x0000002c },
{ 0x30, 0, 0, 0x00000036 },
{ 0x15, 3, 4, 0x00000006 },
{ 0x15, 0, 3, 0x00000800 },
{ 0x30, 0, 0, 0x00000017 },
{ 0x15, 0, 1, 0x00000006 },
{ 0x6, 0, 0, 0x00040000 },
{ 0x6, 0, 0, 0x00000000 },

linux/filter.h macros

/* check if ethernet type field is ip6 */ 
BPF_STMT(BPF_LD+BPF_H+BPF_ABS, 12),
BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, 0x86dd, 0, 5),
/* check if next header field is tcp */
BPF_STMT(BPF_LD+BPF_H+BPF_ABS, 20),
BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, 0x6, 6, 0),
/* check if next header field is ip6 fragment header */
BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, 0x2c, 0, 6),
BPF_STMT(BPF_LD+BPF_H+BPF_ABS, 54),
/* check if the next header field of the fragment header is tcp */
BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, 0x6, 3, 4),
/* check if ethernet type field is ip4 */
BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, 0x800, 0, 3),
/* check if ip4 protocol field is tcp */
BPF_STMT(BPF_LD+BPF_B+BPF_ABS, 23),
BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, 0x6, 0, 1),
/* reutrn the entire packet */
BPF_STMT(BPF_RET+BPF_K, 0x40000),
/* discard the packet */
BPF_STMT(BPF_RET+BPF_K, 0),

=========== TCP FLAG SYN ==================================

tcpdump 'tcp[tcpflags] == tcp-syn' -d

(000) ldh      [12]
(001) jeq      #0x800           jt 2   jf 10
(002) ldb      [23]
(003) jeq      #0x6             jt 4   jf 10
(004) ldh      [20]
(005) jset     #0x1fff          jt 10  jf 6
(006) ldxb     4*([14]&0xf)
(007) ldb      [x + 27]
(008) jeq      #0x2             jt 9   jf 10
(009) ret      #262144
(010) ret      #0

tcpdump 'tcp[tcpflags] == tcp-syn' -dd

{ 0x28, 0, 0, 0x0000000c },
{ 0x15, 0, 8, 0x00000800 },
{ 0x30, 0, 0, 0x00000017 },
{ 0x15, 0, 6, 0x00000006 },
{ 0x28, 0, 0, 0x00000014 },
{ 0x45, 4, 0, 0x00001fff },
{ 0xb1, 0, 0, 0x0000000e },
{ 0x50, 0, 0, 0x0000001b },
{ 0x15, 0, 1, 0x00000002 },
{ 0x6, 0, 0, 0x00040000 },
{ 0x6, 0, 0, 0x00000000 },

linux/filter.h macros

/* check if ethernet type field is ip4 */
BPF_STMT(BPF_LD+BPF_H+BPF_ABS, 12),
BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, 0x800, 0, 8),
/* check if ip protocol field is tcp */
BPF_STMT(BPF_LD+BPF_B+BPF_ABS, 23),
BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, 0x6, 0, 6),
/* check if fragment offset is 0 */
BPF_STMT(BPF_LD+BPF_H+BPF_ABS, 20),
BPF_JUMP(BPF_JMP+BPF_JSET+BPF_K, 0x1fff, 4, 0),
/* load ip header length in the index register */
BPF_STMT(BPF_LDX+BPF_B+BPF_MSH, 14),
/* check if tcp syn flag is set */
BPF_STMT(BPF_LD+BPF_B+BPF_IND, 27),
BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, 0x2, 0, 1),
/* return the entire packet */
BPF_STMT(BPF_RET+BPF_K, 0x40000),
/* discard the packet */
BPF_STMT(BPF_RET+BPF_K, 0),

================ ICMP ECHO-REPLY ==========================

tcpdump icmp[icmptype] = icmp-echoreply -d

(000) ldh      [12]
(001) jeq      #0x800           jt 2   jf 10
(002) ldb      [23]
(003) jeq      #0x1             jt 4   jf 10
(004) ldh      [20]
(005) jset     #0x1fff          jt 10  jf 6
(006) ldxb     4*([14]&0xf)
(007) ldb      [x + 14]
(008) jeq      #0x0             jt 9   jf 10
(009) ret      #262144
(010) ret      #0

tcpdump icmp[icmptype] = icmp-echoreply -dd

{ 0x28, 0, 0, 0x0000000c },
{ 0x15, 0, 8, 0x00000800 },
{ 0x30, 0, 0, 0x00000017 },
{ 0x15, 0, 6, 0x00000001 },
{ 0x28, 0, 0, 0x00000014 },
{ 0x45, 4, 0, 0x00001fff },
{ 0xb1, 0, 0, 0x0000000e },
{ 0x50, 0, 0, 0x0000000e },
{ 0x15, 0, 1, 0x00000000 },
{ 0x6, 0, 0, 0x00040000 },
{ 0x6, 0, 0, 0x00000000 },

linux/filter.h macros

 /* check if ethernet field type is ip4 */            
 BPF_STMT(BPF_LD+BPF_H+BPF_ABS, 12),                  
 BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, 0x800, 0, 8),        
 /* check if ip protcol field is icmp */  
 BPF_STMT(BPF_LD+BPF_B+BPF_ABS, 23),                  
 BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, 0x1, 0, 6),          
 /* check if fragment offset is 0 */                  
 BPF_STMT(BPF_LD+BPF_B+BPF_ABS, 20),                  
 BPF_JUMP(BPF_JMP+BPF_JSET+BPF_K, 0x1fff, 4, 0),      
 /* load ip header length in the index register */    
 BPF_STMT(BPF_LDX+BPF_B+BPF_MSH, 14),                 
 /* check if icmp type is echoreply */                
 BPF_STMT(BPF_LD+BPF_B+BPF_IND, 14),                  
 BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, 0x0, 0, 1),          
 /* return the entire packet */                       
 BPF_STMT(BPF_RET+BPF_K, 0x40000),                  
 /* discard the packet */                             
 BPF_STMT(BPF_RET+BPF_K, 0),   

============== udp and src port 1030 =======================

tcpdump 'udp and src port 1030' -d

(000) ldh      [12]
(001) jeq      #0x86dd          jt 2   jf 6
(002) ldb      [20]
(003) jeq      #0x11            jt 4   jf 15
(004) ldh      [54]
(005) jeq      #0x406           jt 14  jf 15
(006) jeq      #0x800           jt 7   jf 15
(007) ldb      [23]
(008) jeq      #0x11            jt 9   jf 15
(009) ldh      [20]
(010) jset     #0x1fff          jt 15  jf 11
(011) ldxb     4*([14]&0xf)
(012) ldh      [x + 14]
(013) jeq      #0x406           jt 14  jf 15
(014) ret      #262144
(015) ret      #0

tcpdump 'udp and src port 1030' -dd

{ 0x28, 0, 0, 0x0000000c },
{ 0x15, 0, 4, 0x000086dd },
{ 0x30, 0, 0, 0x00000014 },
{ 0x15, 0, 11, 0x00000011 },
{ 0x28, 0, 0, 0x00000036 },
{ 0x15, 8, 9, 0x00000406 },
{ 0x15, 0, 8, 0x00000800 },
{ 0x30, 0, 0, 0x00000017 },
{ 0x15, 0, 6, 0x00000011 },
{ 0x28, 0, 0, 0x00000014 },
{ 0x45, 4, 0, 0x00001fff },
{ 0xb1, 0, 0, 0x0000000e },
{ 0x48, 0, 0, 0x0000000e },
{ 0x15, 0, 1, 0x00000406 },
{ 0x6, 0, 0, 0x00040000 },
{ 0x6, 0, 0, 0x00000000 },

linux/filter.h macros

/* check if the ethernet type field is ip6 */
BPF_STMT(BPF_LD+BPF_H+BPF_ABS, 12),
BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, 0x86dd, 0, 4),
/* check if the next header field is UDP */
BPF_STMT(BPF_LD+BPF_B+BPF_ABS, 20),
BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, 0x11, 0, 11),
/* check if the UPD header src port is 1030 */
BPF_STMT(BPF_LD+BPF_B+BPF_ABS, 54),
BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, 0x406, 8, 9),
/* check if the ethernet type field is ip4 */
BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, 0x800, 0, 8),
/* check if the ip4 header protocol field is UDP */
BPF_STMT(BPF_LD+BPF_B+BPF_ABS, 23),
BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, 0x11, 0, 6),
/* check if ip4 header fragment offset is 0 */
BPF_STMT(BPF_LD+BPF_H+BPF_ABS, 20), 
BPF_JUMP(BPF_JMP+BPF_JSET+BPF_K, 0x1fff, 4, 0),
/* load ip4 header length in the index register */
BPF_STMT(BPF_LDX+BPF_B+BPF_MSH, 14),
/* check if UDP src port is 1030 */
BPF_STMT(BPF_LD+BPF_H+BPF_IND, 14),
BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, 0x406, 0, 1),
/* return the entire packet */
BPF_STMT(BPF_RET+BPF_K, 0x40000),
/* discard the packet */
BPF_STMT(BPF_RET+BPF_K, 0),

============== udp port 67 and port 68  ==================== 

tcpdump 'udp and port 67 and port 68' -d

(000) ldh      [12]
(001) jeq      #0x86dd          jt 2   jf 11
(002) ldb      [20]
(003) jeq      #0x11            jt 4   jf 25
(004) ldh      [54]
(005) jeq      #0x43            jt 6   jf 8
(006) ldh      [56]
(007) jeq      #0x44            jt 24  jf 25
(008) jeq      #0x44            jt 9   jf 25
(009) ldh      [56]
(010) jeq      #0x43            jt 24  jf 25
(011) jeq      #0x800           jt 12  jf 25
(012) ldb      [23]
(013) jeq      #0x11            jt 14  jf 25
(014) ldh      [20]
(015) jset     #0x1fff          jt 25  jf 16
(016) ldxb     4*([14]&0xf)
(017) ldh      [x + 14]
(018) jeq      #0x43            jt 19  jf 21
(019) ldh      [x + 16]
(020) jeq      #0x44            jt 24  jf 25
(021) jeq      #0x44            jt 22  jf 25
(022) ldh      [x + 16]
(023) jeq      #0x43            jt 24  jf 25
(024) ret      #262144
(025) ret      #0

tcpdump 'udp and port 67 and port 68' -dd

{ 0x28, 0, 0, 0x0000000c },
{ 0x15, 0, 9, 0x000086dd },
{ 0x30, 0, 0, 0x00000014 },
{ 0x15, 0, 21, 0x00000011 },
{ 0x28, 0, 0, 0x00000036 },
{ 0x15, 0, 2, 0x00000043 },
{ 0x28, 0, 0, 0x00000038 },
{ 0x15, 16, 17, 0x00000044 },
{ 0x15, 0, 16, 0x00000044 },
{ 0x28, 0, 0, 0x00000038 },
{ 0x15, 13, 14, 0x00000043 },
{ 0x15, 0, 13, 0x00000800 },
{ 0x30, 0, 0, 0x00000017 },
{ 0x15, 0, 11, 0x00000011 },
{ 0x28, 0, 0, 0x00000014 },
{ 0x45, 9, 0, 0x00001fff },
{ 0xb1, 0, 0, 0x0000000e },
{ 0x48, 0, 0, 0x0000000e },
{ 0x15, 0, 2, 0x00000043 },
{ 0x48, 0, 0, 0x00000010 },
{ 0x15, 3, 4, 0x00000044 },
{ 0x15, 0, 3, 0x00000044 },
{ 0x48, 0, 0, 0x00000010 },
{ 0x15, 0, 1, 0x00000043 },
{ 0x6, 0, 0, 0x00040000 },
{ 0x6, 0, 0, 0x00000000 },

linux/filter.h macros

/* check if the ethernet type field is ip6 */
BPF_STMT(BPF_LD+BPF_H+BPF_ABS, 12),
BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, 0x86dd, 0, 9),
/* check if the next header field is UDP */
BPF_STMT(BPF_LD+BPF_B+BPF_ABS, 20),
BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, 0x11, 0, 21),
/* check if the UPD header src port is 67 */
BPF_STMT(BPF_LD+BPF_B+BPF_ABS, 54),
BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, 0x43,  0, 2),
/* check if the UPD header dst port is 68 */
BPF_STMT(BPF_LD+BPF_B+BPF_ABS, 56),
BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, 0x44, 16, 17),
/* check if the UDP header src port is 68 */
BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, 0x44,  0, 16),
/* check if the UDP header dst port is 67 */
BPF_STMT(BPF_LD+BPF_B+BPF_ABS, 56),
BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, 0x43,  13, 14),
/* check if the ethernet type field is ip4 */
BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, 0x800, 0, 13),
/* check if the ip4 header protocol field is UDP */
BPF_STMT(BPF_LD+BPF_B+BPF_ABS, 23),
BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, 0x11, 0, 11),
/* check if ip4 header fragment offset is 0 */
BPF_STMT(BPF_LD+BPF_H+BPF_ABS, 20), 
BPF_JUMP(BPF_JMP+BPF_JSET+BPF_K, 0x1fff, 9, 0),
/* load ip4 header length in the index register */
BPF_STMT(BPF_LDX+BPF_B+BPF_MSH, 14),
/* check if UDP src port is 67 */
BPF_STMT(BPF_LD+BPF_H+BPF_IND, 14),
BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, 0x43, 0, 2),
/* check if UDP dst port is 68 */
BPF_STMT(BPF_LD+BPF_H+BPF_IND, 16),
BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, 0x44, 3, 4),
/* check if UDP src port is 68 */
BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, 0x44, 0, 3),
/* check if UDP dst port is 67 */
BPF_STMT(BPF_LD+BPF_H+BPF_IND, 16),
BPF_JUMP(BPF_JMP+BPF_JEQ+BPF_K, 0x43, 0, 1),
/* return the entire packet */                       
BPF_STMT(BPF_RET+BPF_K, 0x40000),                  
/* discard the packet */                             
BPF_STMT(BPF_RET+BPF_K, 0),            


